version: 2.1
description: Security tooling steps


# THe security orb uses existing orbs to leverage already-coded testing steps.
orbs:
  anchore: anchore/anchore-engine@1.5.0
  snyk: snyk/snyk@0.0.8


executors:
  container_builder:
    description: Simple base image with orb-specific variables set
    docker:
    - image: circleci/buildpack-deps:stretch
    environment:
      ANCHORE_VERSION: "v0.4.1"


# Most orb commands follow a common step format:
# 1) [Install] - Install any pre-requisites such as packages, dependencies, etc.
# 2) [Prepare] - Prepare any files or directories that need to be set up for tool output.
# 3) [Run] - Run the associated tool
# 4) [Post] - Do any post-execution steps, such as uploading artifacts, renaming output files, etc.
commands:

  # This command downloads and runs the custom circleci-security-parser tool to go through
  # all tool output generated by any commands in this orb, and merge them (per job) into one
  # csv.
  parse:
    parameters:
      input_directory:
        default: ~/output
        type: string
        description: "The directory containing raw tool output"
      output_directory:
        default: ~/output/parsed_output
        type: string
        description: "The directory to save parsed tool output to."
    steps:
      - run:
          name: "[security/parse] [Install] Python 3.7.4"
          command: |
            # If Python 3.7 is not available, we'll have to build it manually.
            if [[ ! $(which python3.7) ]]; then
              curl -O https://www.python.org/ftp/python/3.7.4/Python-3.7.4.tar.xz
              tar -xf Python-3.7.4.tar.xz
              cd Python-3.7.4 && ./configure && make build_all && sudo make altinstall
            fi
      - run:
          name: "[security/parse] [Install] pip"
          command: |
            git clone https://github.com/salidas/circleci-security-parser
            curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py && sudo python3.7 get-pip.py  
      - run:
          name: "[security/parse] [Install] circleci-security-parser"
          command: |
            pip install --user -r circleci-security-parser/requirements.txt
      - run:
          name: "[security/parse] [Prepare] Create folder"
          command: |
            mkdir -p << parameters.output_directory >> 
      - run:
          name: "[security/parse] [Run] circleci-security-parser"
          command: |
            python3.7 circleci-security-parser/main.py -i << parameters.input_directory>> -o << parameters.output_directory >>
      - store_artifacts:
          path: << parameters.output_directory >>

  # Spins up the Anchore engine in preparation for remote/local image scanning commands.
  anchore_start_engine:
    parameters:
      timeout:
        default: "600"
        type: string
        description: Length of time allocated before the build stops.
    steps:
      - run:
          name: "[security/anchore_start_engine] [Install] Starting engine"
          command: |
            ANCHORE_VERSION="${ANCHORE_VERSION}"
            TIMEOUT="<< parameters.timeout >>"
            docker run -d --name anchore-engine "anchore/inline-scan:${ANCHORE_VERSION}" start
            docker exec -e TIMEOUT="$TIMEOUT" -it anchore-engine bash -lc 'anchore_ci_tools.py --wait --timeout "$TIMEOUT"'

  # Leverages Anchore's inline-engine container to pull an image from a remote registry, then compare scan findings
  # against an Anchore security policy.
  anchore_scan_remote:
    parameters:
      image_name:
        type: string
        description: Image repository & tag (eg - "docker.io/anchore/anchore-engine:latest").
      timeout:
        type: string
        description: Length of time allocated before the build stops.
      private:
        default: false
        type: boolean
        description: The status of the remote registry
      username:
        default: $DOCKER_USER
        type: string
      password:
        default: $DOCKER_PASS
        type: string
      registry:
        default: docker.io
        type: string
      output_directory:
        default: ~/output/anchore
        type: string
    steps:
      - when:
          condition: << parameters.registry >>
          steps:
            - anchore/add_private_registry:
                registry_name: << parameters.registry >>
                registry_user: << parameters.username >>
                registry_pass: << parameters.password >>
      - run:
          name: "[security/anchore_scan_remote] [Run] Anchore scan of remote image"
          command: |
            IMAGE_NAME="<< parameters.image_name >>"
            TIMEOUT="<< parameters.timeout >>"
            docker exec -e IMAGE_NAME="$IMAGE_NAME" -e TIMEOUT="$TIMEOUT" -it anchore-engine bash -lc 'anchore_ci_tools.py --analyze --report --image "$IMAGE_NAME" --timeout "$TIMEOUT"'
            docker exec -e IMAGE_NAME="$IMAGE_NAME" -it anchore-engine bash -lc 'anchore-cli image get "$IMAGE_NAME"'
            docker cp anchore-engine:/anchore-engine/anchore-reports/ ./
      - run:
          name: "[security/anchore_scan_remote] [Artifacts] Rename and move output"
          command: |
            mkdir -p << parameters.output_directory >>
            mv anchore-reports/* << parameters.output_directory >>
      - store_artifacts:
          path: << parameters.output_directory >>

  # Leverages Anchore's inline-engine image to scan Docker images that were built locally on the build container(s). 
  anchore_scan_local:
    parameters:
      image_name:
        type: string
        description: Image name & tag, e.g. "anchore-engine:latest".
      timeout:
        type: string
        description: Length of time allocated before the build stops.
      dockerfile:
        type: string
        description: The path to the Dockerfile used to build the local image
        default: ""
      policy:
        type: string
        description: Anchore security policy to compare the scan results against
        default: "${HOME}/project/.circleci/.anchore/policy_bundle.json"
      output_directory:
        default: ~/output/anchore
        type: string
    steps:
      - run:
          name: "[security/anchore_scan_local] [Install] bash, curl"
          command: |
            if [[ ! $(which bash) ]]; then
              (set +o pipefail; apk add bash || apt-get install -y bash || yum install -y bash)
            fi
            if [[ ! $(which curl) ]]; then
              (set +o pipefail; apk add curl || apt-get install -y curl || yum install -y curl)
            fi
      - run:
          name: "[security/anchore_scan_local] [Prepare] Create output folder"
          command: mkdir -p << parameters.output_directory >>
      - run:
          name: "[security/anchore_scan_local] [Run] Anchore scan of local image"
          command: |
            POLICY_FAILURE="false"

            # Because this is in a run step, I have to use a magic variable to store the Anchore version
            ANCHORE_VERSION="v0.4.1"

            TIMEOUT="<< parameters.timeout >>"
            POLICY_BUNDLE_PATH="<< parameters.policy >>"
            DOCKERFILE_PATH="<< parameters.dockerfile >>"
            IMAGE_NAME="<< parameters.image_name >>"

            run_cmd="curl -s https://ci-tools.anchore.io/inline_scan-${ANCHORE_VERSION} | bash -s -- -r -t $TIMEOUT"
            if $POLICY_FAILURE; then
              run_cmd="$run_cmd -f"
            fi
            if [[ ! -z $POLICY_BUNDLE_PATH ]] && [[ -f $POLICY_BUNDLE_PATH ]]; then
              run_cmd="$run_cmd -b $POLICY_BUNDLE_PATH"
            else
              echo "ERROR - could not find policy bundle $POLICY_BUNDLE_PATH - using default policy bundle."
            fi
            if [[ ! -z $DOCKERFILE_PATH ]] && [[ -f $DOCKERFILE_PATH ]]; then
              run_cmd="$run_cmd -d $DOCKERFILE_PATH"
            else
              echo "ERROR - could not find Dockerfile $DOCKERFILE_PATH - Dockerfile not included in scan."
            fi
            run_cmd="$run_cmd $IMAGE_NAME"
            eval "$run_cmd"
      - run:
          name: "[security/anchore_scan_local] [Post] Move artifacts"
          command: mv anchore-reports/* << parameters.output_directory >>
      - store_artifacts:
          path: << parameters.output_directory >>


  # Uses detect-secrets to carry out a one-time baseline scan, to look for any and all credentials each build.
  # It is up to the developers to identify known false-positives or commit a known baseline so that future runs
  # only show unidentified credentials.
  detect-secrets_scan:
    parameters:
      directory:
        default: /home/circleci/project
        type: string
        description: The directory to run detect-secrets on
      output_directory:
        default: ~/output/detect-secrets
        type: string
        description: The location to save output to
      additional_arguments:
        default: ""
        type: string
        description: Additional CLI arguments that should be run
    steps:
      - run:
          name: "[security/detect-secrets_scan] [Install] detect-secrets"
          command: pip install --user detect-secrets
      - run:
          name: "[security/detect-secrets_scan] [Prepare] Create output folder"
          command: mkdir -p << parameters.output_directory >>
      - run:
          name: "[security/detect-secrets_scan] [Run] detect-secrets"
          command: detect-secrets scan << parameters.additional_arguments >> << parameters.directory >> | tee << parameters.output_directory >>/results_detect-secrets.json
      - store_artifacts:
          path: << parameters.output_directory >>


  # Uses DumpsterDiver to look for a variety of credentials (such as passwords, AWS keys, private keys, etc).
  dumpsterdiver_scan:
    parameters:
      directory:
        default: ~/project
        type: string
        description: The directory to run DumpsterDiver on.
      installation_directory:
        default: ~/dumpsterdiver
        type: string
        description: The location where DumpsterDiver is
      output_directory:
        default: ~/output/dumpsterdiver
        type: string
        description: The location to save output to
      additional_arguments:
        default: ""
        type: string
        description: Additional CLI arguments that should be run
    steps:
      - run:
          name: "[security/dumpsterdiver_scan] [Install] python3-dev, pip requirements"
          command: |
            git clone https://github.com/securing/DumpsterDiver << parameters.installation_directory >>
            sudo apt-get install python3-dev && pip install --user -r << parameters.installation_directory >>/requirements.txt
      - run:
          name: "[DumpsterDiver] [Prepare] Create folder"
          command: mkdir -p << parameters.output_directory >>
      - run:
          name: "[security/dumpsterdiver_scan] [Run] DumpsterDiver.py"
          command: |
            cd << parameters.installation_directory >> 
            python DumpsterDiver.py << parameters.additional_arguments >> -o << parameters.output_directory >>/results_dumpsterdiver_standard.json -p << parameters.directory >> -s -a
            python DumpsterDiver.py << parameters.additional_arguments >> -o << parameters.output_directory >>/results_dumpsterdiver_aws_1.json -p << parameters.directory >> --grep-words *aws_access_key_id* *aws_secret_access_key*
            python DumpsterDiver.py << parameters.additional_arguments >> -o << parameters.output_directory >>/results_dumpsterdiver_aws_2.json -p << parameters.directory >> --min-key 40 --max-key 40 --entropy 4.3
            python DumpsterDiver.py << parameters.additional_arguments >> -o << parameters.output_directory >>/results_dumpsterdiver_azure.json -p << parameters.directory >> --min-key 66 --max-key 66 --entropy 5.1
            python DumpsterDiver.py << parameters.additional_arguments >> -o << parameters.output_directory >>/results_dumpsterdiver_private_keys.json -p << parameters.directory >> --min-key 76 --max-key 76 --entropy 5.1
            python DumpsterDiver.py << parameters.additional_arguments >> -o << parameters.output_directory >>/results_dumpsterdiver_passwords.json -p << parameters.directory >> --min-pass 8 --max-pass 20 --pass-complex 7
      - store_artifacts:
           path: << parameters.output_directory >> 
                     

  # Runs Snyk on a locally built or pulled container image to find any outdated and/or vulnerable 
  # packages.
  snyk_image_scan:
    parameters:
      image_name:
        type: string
        description: The container image to be scanned by Snyk
      fail_on_issues:
        default: false
        type: boolean
        description: Should the build fail if vulns have been found?
      monitor_on_build:
        default: false
        type: boolean
        description: Determine whether the image should be monitored on snyk.io after scan
      snyk_token:
        default: SNYK_TOKEN
        type: string
        description: The environment variable containing the snyk.io API token
      output_directory:
        default: ~/output/snyk
        type: string
        description: The location to save output to
      additional_arguments:
        default: ""
        type: string
        description: Additional CLI arguments that should be run
    steps:
      - run:
          name: "[security/snyk_image_scan] [Install] bash, curl, sudo"
          command: |
            if [[ ! $(which bash) ]]; then
              (set +o pipefail; apk add bash || apt-get install -y bash || yum install -y bash)
            fi
            if [[ ! $(which curl) ]]; then
              (set +o pipefail; apk add curl || apt-get install -y curl || yum install -y curl)
            fi
            if [[ ! $(which sudo) ]]; then
              (set +o pipefail; apk add sudo || apt-get install -y sudo || yum install -y sudo)
            fi
      - run:
          name: "[security/snyk_image_scan] [Prepare] Create folder"
          command: mkdir -p << parameters.output_directory >>
      - snyk/scan:
          docker-image-name: << parameters.image_name >>
          fail-on-issues: << parameters.fail_on_issues >>
          monitor-on-build: << parameters.monitor_on_build >>
          token-variable: << parameters.snyk_token >>
          additional-arguments: "<< parameters.additional_arguments >> --json > << parameters.output_directory >>/results_image_snyk.json"
      - store_artifacts:
          path: << parameters.output_directory >>


  # Runs Snyk on a node project, looking for outdated and/or vulnerable node packages.
  snyk_node_scan:
    parameters:
      fail_on_issues:
        default: false
        type: boolean
        description: Should the build fail if vulns have been found?
      monitor_on_build:
        default: false
        type: boolean
        description: Determine whether the image should be monitored on snyk.io after scan
      snyk_token:
        default: SNYK_TOKEN
        type: string
        description: The environment variable containing the snyk.io API token
      output_directory:
        default: ~/output/snyk
        type: string
        description: The location to save output to
      additional_arguments:
        default: ""
        type: string
        description: Additional CLI arguments that should be run
    steps:
      - run:
          name: "[security/snyk_node_scan] [Install] bash, curl, sudo"
          command: |
            if [[ ! $(which bash) ]]; then
              (set +o pipefail; apk add bash || apt-get install -y bash || yum install -y bash)
            fi
            if [[ ! $(which curl) ]]; then
              (set +o pipefail; apk add curl || apt-get install -y curl || yum install -y curl)
            fi
            if [[ ! $(which sudo) ]]; then
              (set +o pipefail; apk add sudo || apt-get install -y sudo || yum install -y sudo)
            fi
      - run:
          name: "[security/snyk_node_scan] [Prepare] Create folder"
          command: mkdir -p << parameters.output_directory >>
      - snyk/scan:
          fail-on-issues: << parameters.fail_on_issues >>
          monitor-on-build: << parameters.monitor_on_build >>
          token-variable: << parameters.snyk_token >>
          additional-arguments: "<< parameters.additional_arguments >> --json > << parameters.output_directory >>/results_node_snyk.json"
      - store_artifacts:
          path: << parameters.output_directory >>


  # Leverages audit-ci, which runs yarn audit or npm audit depending on what's available.
  # audit-ci then checks for any outdated and/or vulnerable node packages and reports in JSON format.
  node_audit:
    parameters:
      threshold:
        default: low
        type: string
        description: The severity at which audit-ci will begin to report issues
      target_directory:
        default: ~/project
        type: string
        description: The location of the node project to be scanned
      output_directory:
        default: ~/output/audit-ci
        type: string
        description: The location to save the audit output to
      additional_arguments:
        default: ""
        type: string
        description: Additional CLI arguments that should be run with
    steps:
      - run:
          name: "[security/node_audit] [Install] audit-ci"
          command: |
            if [[ ! $(which audit-ci) ]]; then
              (set +o pipefail; npm i --save-dev audit-ci || yarn add -D audit-ci)
            fi
      - run:
          name: "[security/node_audit] [Prepare] Create folder"
          command: mkdir -p << parameters.output_directory >>
      - run:
          name: "[security/node_audit] [Run] audit-ci"
          command: |
            cd << parameters.target_directory >> && $(node_modules/audit-ci/bin/audit-ci --<< parameters.threshold >> --report-type full << parameters.additional_arguments >> > << parameters.output_directory >>/unfinished_audit-ci.json || true)
      - run:
          name: "[security/node_audit] [Post] Remove non-JSON string from start of results file"
          command: |
            tail -n +2 << parameters.output_directory >>/unfinished_audit-ci.json > << parameters.output_directory >>/results_audit-ci.json
      - store_artifacts:
          path: << parameters.output_directory >>


jobs:
  # A job that runs all available secrets/credentials scanning commands.
  secrets:
    docker:
      - image: circleci/python:3.6.9
    parameters:
      directory:
        default: /home/circleci/project
        type: string
        description: The directory to run secrets detection tools on.
    steps:
      - setup_remote_docker:
          docker_layer_caching: true
      - checkout
      - dumpsterdiver_scan:
          directory: << parameters.directory >>
      - detect-secrets_scan:
          directory: << parameters.directory >>
      - parse

  # A job that runs all available commands that focus on scanning node projects.
  # The job checks out the repository going through a build, installs its node dependencies
  # then runs commands on the downloaded items.
  node:
    docker:
      - image: circleci/node:latest
    parameters:
      yarn:
        default: false
        type: boolean
        description: Determines whether Yarn or NPM is used
      target_directory:
        default: ~/project
        type: string
        description: The location of the repository to be assessed
    steps:
      - setup_remote_docker:
          docker_layer_caching: true
      - checkout
      - when:
          condition: << parameters.yarn >>
          steps:
            - run:
                name: "[security/node] [Install] Dependencies (yarn)"  
                command: cd << parameters.target_directory >> && yarn install
      - unless:
          condition: << parameters.yarn >>
          steps:
            - run:
                name: "[security/node] [Install] Dependencies (npm)"
                command: cd << parameters.target_directory >> && npm install
      - snyk_node_scan
      - node_audit:
          target_directory: << parameters.target_directory >> 
      - parse


  # Checks a container image hosted remotely in a public or private registry by pulling it and then
  # running all available local container image checks.
  container-remote:
    executor: container_builder
    parameters:
      image_name:
        type: string
        description: Image org, name & tag (eg - "anchore/anchore-engine:latest").
      timeout:
        default: "600"
        type: string
        description: Length of time allocated before the build stops.
      private:
        default: false
        type: boolean
        description: The status of the remote registry
      username:
        default: $DOCKER_USER
        type: string
      password:
        default: $DOCKER_PASS
        type: string
      registry:
        default: docker.io
        type: string
    steps:
      - setup_remote_docker:
          docker_layer_caching: true
      - run:
          name: "[security/container-remote] [Prepare] Image pull for Snyk"
          command: |
            docker pull << parameters.registry >>/<< parameters.image_name >>
      - snyk_image_scan:
          image_name: << parameters.image_name >>
      - anchore_start_engine:
          timeout: << parameters.timeout >>
      - anchore_scan_remote:
          image_name: << parameters.image_name >>
          timeout: << parameters.timeout >>
          private: << parameters.private >>
          username: << parameters.username >>
          password: << parameters.password >>
          registry: << parameters.registry >>
      - parse
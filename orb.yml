version: 2.1
description: Security tooling steps

orbs:
  anchore: anchore/anchore-engine@1.5.0

executors:
  anchore_engine:
    description: |
      Docker stable image with ANCHORE_VERSION environment variable set.
    docker:
    - image: docker:stable
    environment:
      ANCHORE_VERSION: v0.4.1

commands:
  anchore_start_engine:
    parameters:
      timeout:
        type: string
        description: Length of time allocated before the build stops.
    steps:
      - run:
          name: Starting the Anchore engine...
          command: |
            ANCHORE_VERSION="${ANCHORE_VERSION}"
            TIMEOUT="<< parameters.timeout >>"
            docker run -d --name anchore-engine "anchore/inline-scan:${ANCHORE_VERSION}" start
            docker exec -e TIMEOUT="$TIMEOUT" -it anchore-engine bash -lc 'anchore_ci_tools.py --wait --timeout "$TIMEOUT"'

  anchore_scan_remote:
    parameters:
      image_name:
        type: string
        description: Image repository & tag (eg - "docker.io/anchore/anchore-engine:latest").
      timeout:
        type: string
        description: Length of time allocated before the build stops.
      private:
        default: false
        type: boolean
        description: The status of the remote registry
      username:
        default: $DOCKER_USER
        type: string
      password:
        default: $DOCKER_PASS
        type: string
      registry:
        default: docker.io
        type: string
    steps:
      - when:
          condition: << parameters.registry >>
          steps:
            - anchore/add_private_registry:
                registry_name: << parameters.registry >>
                registry_user: << parameters.username >>
                registry_pass: << parameters.password >>
      - run:
          name: Analysing with Anchore
          command: |
            IMAGE_NAME="<< parameters.image_name >>"
            TIMEOUT="<< parameters.timeout >>"
            docker exec -e IMAGE_NAME="$IMAGE_NAME" -e TIMEOUT="$TIMEOUT" -it anchore-engine bash -lc 'anchore_ci_tools.py --analyze --report --image "$IMAGE_NAME" --timeout "$TIMEOUT"'
            docker exec -e IMAGE_NAME="$IMAGE_NAME" -it anchore-engine bash -lc 'anchore-cli image get "$IMAGE_NAME"'
            docker cp anchore-engine:/anchore-engine/anchore-reports/ ./
      - anchore/parse_reports
      - store_artifacts:
          path: anchore-reports

  anchore_scan_local:
    parameters:
      image_name:
        type: string
        description: Image name & tag, e.g. "anchore-engine:latest".
      timeout:
        type: string
        description: Length of time allocated before the build stops.
      dockerfile:
        type: string
        description: The path to the Dockerfile used to build the local image
        default: ""
    steps:
      - run:
          name: Analysing locally with Anchore
          command: |
            if [[ ! $(which bash) ]]; then
              (set +o pipefail; apk add bash || apt-get install -y bash || yum install -y bash)
            fi
            if [[ ! $(which curl) ]]; then
              (set +o pipefail; apk add curl || apt-get install -y curl || yum install -y curl)
            fi

            POLICY_FAILURE="false"

            # Because this is in a command, I have to use a magic variable to store the Anchore version
            ANCHORE_VERSION="v0.4.1"

            TIMEOUT="<< parameters.timeout >>"
            POLICY_BUNDLE_PATH="${HOME}/project/.circleci/.anchore/policy_bundle.json"
            DOCKERFILE_PATH="<< parameters.dockerfile >>"
            IMAGE_NAME="<< parameters.image_name >>"

            run_cmd="curl -s https://ci-tools.anchore.io/inline_scan-${ANCHORE_VERSION} | bash -s -- -r -t $TIMEOUT"
            if $POLICY_FAILURE; then
              run_cmd="$run_cmd -f"
            fi
            if [[ ! -z $POLICY_BUNDLE_PATH ]] && [[ -f $POLICY_BUNDLE_PATH ]]; then
              run_cmd="$run_cmd -b $POLICY_BUNDLE_PATH"
            else
              echo "ERROR - could not find policy bundle $POLICY_BUNDLE_PATH - using default policy bundle."
            fi
            if [[ ! -z $DOCKERFILE_PATH ]] && [[ -f $DOCKERFILE_PATH ]]; then
              run_cmd="$run_cmd -d $DOCKERFILE_PATH"
            else
              echo "ERROR - could not find Dockerfile $DOCKERFILE_PATH - Dockerfile not included in scan."
            fi
            run_cmd="$run_cmd $IMAGE_NAME"
            eval "$run_cmd"
      - anchore/parse_reports
      - store_artifacts:
          path: anchore-reports

  dumpsterdiver_retrieve:
    parameters:
      installation_directory:
        default: ~/dumpsterdiver
        type: string
        description: The location to download DumpsterDiver to
    steps:
      - run:
          name: Clone DumpsterDiver from GitHub repository
          command: git clone https://github.com/securing/DumpsterDiver << parameters.installation_directory >>
      - run:
          name: Install DumpsterDiver's requirements
          commaand: pip install -r << parameters.installation_directory >>/requirements.txt

  dumpsterdiver_scan:
    parameters:
      directory:
        default: $CIRCLE_WORKING_DIRECTORY
        type: string
        description: The directory to run DumpsterDiver on.
      installation_directory:
        default: ~/DumpsterDiver
        type: string
        description: The location where DumpsterDiver is
    steps:
      - run:
          name: Create directory to store results
          command: mkdir ~/output/dumpsterdiver
      - run:
          name: Use DumpsterDiver to scan a directory
          command: python ~/dumpsterdiver/DumpsterDiver.py -o ~/output/dumpsterdiver/results_dumpsterdiver.json -p << parameters.directory >> -s -a
      - store_artifacts:
          path: ~/output/dumpsterdiver

jobs:
  # Check a directory for any secrets such as private keys, API keys, etc.
  secrets:
    docker:
      - image: circleci/python:latest
    parameters:
      directory:
        default: $CIRCLE_WORKING_DIRECTORY
        type: string
        description: The directory to run secrets detection tools on.
    steps:
      - setup_remote_docker:
          docker_layer_caching: true
      - dumpsterdiver_retrieve
      - dumpsterdiver_scan:
          directory: << parameters.directory >>

  #Â Scan a locally built container image.
  container-local:
    executor: anchore_engine
    parameters:
      image_name:
        type: string
        description: Image name & tag, e.g. "anchore-engine:latest".
      timeout:
        type: string
        description: Length of time allocated before the build stops.
      dockerfile:
        type: string
        description: Dockerfile associated with local build
    steps:
      - setup_remote_docker:
          docker_layer_caching: true
      - anchore_start_engine:
          timeout: << parameters.timeout >>
      - anchore_scan_local:
          image_name: << parameters.image_name >>
          timeout: << parameters.timeout >>
          dockerfile: << parameters.dockerfile >>

  # Scan a container image hosted remotely in a public or private registry
  container-remote:
    executor: anchore_engine
    parameters:
      image_url:
        type: string
        description: Image repository & tag (eg - "docker.io/anchore/anchore-engine:latest").
      timeout:
        type: string
        description: Length of time allocated before the build stops.
      private:
        default: false
        type: boolean
        description: The status of the remote registry
      username:
        default: $DOCKER_USER
        type: string
      password:
        default: $DOCKER_PASS
        type: string
      registry:
        default: docker.io
        type: string
    steps:
      - setup_remote_docker:
          docker_layer_caching: true
      - anchore_start_engine:
          timeout: << parameters.timeout >>
      - anchore_scan_remote:
          image_name: << parameters.image_url >>
          timeout: << parameters.timeout >>
          private: << parameters.private >>
          username: << parameters.username >>
          password: << parameters.password >>
          registry: << parameters.registry >>